### auth.http ###

# -- Variables --
# 定义环境变量，可以在不同的环境中切换 (例如 local, staging, prod)
@hostname = http://localhost:3000
@api_v1 = {{hostname}}/v1

# 使用 IDEA HTTP Client 的动态变量生成一个随机的用户名
@username = testuser{{$randomInt}}@example.com
@password = strongpassword123
@token = eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MSwidXNlcm5hbWUiOiJ0ZXN0dXNlcjQyQGV4YW1wbGUuY29tIiwicm9sZSI6ImFkbWluIiwiaWF0IjoxNzU2NjkwOTc0LCJleHAiOjE3NTY5NTAxNzR9.S2JQS834y9kGXQZ5F7mnexVqCIogPqlgfx0KssYGyto
### 1. 账户密码注册 (Register)
# @name registerRequest
POST {{api_v1}}/auth/register
Content-Type: application/json

{
    "username": "{{username}}",
    "password": "{{password}}"
}

### 分隔符 ###
### ---------------------------------------------------- ###


### 2. 账户密码登录 (Login)
# 使用上面注册时用的相同变量进行登录
POST {{api_v1}}/auth/login
Content-Type: application/json

{
    "username": "{{username}}",
    "password": "{{password}}"
}


### 分隔符 ###
### ---------------------------------------------------- ###


### 3. 微信登录 (wx-login)
#
# !!! 重要提示 !!!
# 下面的 "your_wx_code_here" 必须每次测试时都手动替换。
# 你需要从你的微信开发者工具的控制台中，通过 uni.login() API 来获取一个临时的 code。
# 这个 code 是一次性的，且只有5分钟有效期。
#

POST {{api_v1}}/auth/wx-login
Content-Type: application/json

{
  "code": "your_wx_code_here"
}

### 分隔符 ###
### ---------------------------------------------------- ###


### 4. 获取当前用户信息 (需要认证)
#
# 这个请求依赖于登录请求的成功执行。
# REST Client 插件会自动捕获上一个请求中返回的 token。
# @name getCurrentUser
# @token_variable access_token
GET {{api_v1}}/users/me
Authorization: Bearer {{token}}

### 分隔符 ###
### ---------------------------------------------------- ###


### 5. 保存/更新用户的 API Key (需要认证)
# 使用登录后获取的 token
PUT {{api_v1}}/keys
Authorization: Bearer {{token}}
Content-Type: application/json

{
  "provider": "siliconcloud",
  "apiKey": "sk-XXXXXXXXXXXXXXXXXXXXXXXX"
}


### 分隔符 ###
### ---------------------------------------------------- ###


### 6. 获取用户已配置的 API Key 提供商列表 (需要认证)
# 使用登录后获取的 token
GET {{api_v1}}/keys
Authorization: Bearer {{token}}


### 分隔符 ###
### ---------------------------------------------------- ###


### 7. AI 生成一套题目 (需要认证)
#
# !! 重要 !!
# 1. 执行此请求前，必须先执行登录 (Login) 和保存API Key (Save API Key) 请求。
# 2. provider 和 model 的值需要与你保存的 API Key 以及该平台支持的模型相匹配。
#    例如，如果你使用的是硅基流动，provider可以是 "siliconflow"，model可以是 "deepseek-ai/deepseek-v2-chat"。
#
POST {{api_v1}}/question-sets/generate
Authorization: Bearer {{token}}
Content-Type: application/json

{
  "title": "Nodejs知识",
  "provider": "siliconflow",
  "model": "THUDM/GLM-4.1V-9B-Thinking",
  "domain_major": "互联网",
  "domain_minor": "后端",
  "domain_detail": "Nodejs知识",
  "difficulty": "困难",
  "questionType": "true_false",
  "quantity": 20
}

### 分隔符 ###
### ---------------------------------------------------- ###


### 8. 查询指定题库的生成状态和结果
#
# 使用上一步 (AI 生成题目) 请求返回的 setId
# 你可能需要手动复制 setId 过来，或者如果你的客户端支持，可以使用变量
# @name getQuestionSet
GET {{api_v1}}/question-sets/7
Authorization: Bearer {{token}}

### 分隔符 ###
### ---------------------------------------------------- ###


### 9. 获取我的题库列表 (需要认证)
#
# 这个接口支持分页，你可以修改 URL 中的 page 和 limit 参数来测试
# 例如: /my?page=2&limit=5
#
GET {{api_v1}}/question-sets/my?page=1&limit=10
Authorization: Bearer {{token}}


### 分隔符 ###
### ---------------------------------------------------- ###


### 10. 获取公开的题库列表 (无需认证)
#
# 这个接口任何人都可以访问，不需要提供 token
#
GET {{api_v1}}/question-sets/public?page=1&limit=10

### 分隔符 ###
### ---------------------------------------------------- ###


### 11. 更新题库信息 (需要认证)
#
# !! 重要 !!
# 1. 先执行“获取我的题库列表”请求，从返回结果中找到一个你想修改的题库的 id。
# 2. 将下面 URL 中的 "your_set_id" 替换为那个 id。
#
PUT {{api_v1}}/question-sets/6
Authorization: Bearer {{token}}
Content-Type: application/json

{
  "title": "MySQL 数据库高级知识测评",
  "isPublic": true
}


### 分隔符 ###
### ---------------------------------------------------- ###


### 12. 获取大方向分类
#
# 這個接口用於前端生成下拉菜單
#
GET {{api_v1}}/domains/majors

### 分隔符 ###
### ---------------------------------------------------- ###


### 13. 按分类筛选“我的”题库列表 (需要认证)
#
# 将 URL 中的 "互联" 替换为想筛选的、并且你已经创建过的题库分类
#
GET {{api_v1}}/question-sets/my?domain_major=医疗教育
Authorization: Bearer {{token}}


### 分隔符 ###
### ---------------------------------------------------- ###


### 14. 按分类筛选“公开”题库列表
GET {{api_v1}}/question-sets/public?domain_major=


### 分隔符 ###
### ---------------------------------------------------- ###

### 15. 收藏一个公开题库 (需要认证)
#
# 1. 先执行“获取公开题库列表”请求，从返回结果中找到一个你想收藏的题库的 id。
# 2. 将下面 URL 中的 "public_set_id" 替换为那个 id。
#
POST {{api_v1}}/question-sets/6/favorite
Authorization: Bearer {{token}}


### 分隔符 ###
### ---------------------------------------------------- ###


### 16. 取消收藏一个题库 (需要认证)
#
# 将下面 URL 中的 "public_set_id" 替换为上一步你收藏的那个 id。
#
DELETE {{api_v1}}/question-sets/6/favorite
Authorization: Bearer {{token}}

### 分隔符 ###
### ---------------------------------------------------- ###

### 17. 获取我的收藏题库列表 (需要认证)
#
# 这个接口支持分页
#
GET {{api_v1}}/question-sets/favorites?page=1&limit=10
Authorization: Bearer {{token}}

### 分隔符 ###
### ---------------------------------------------------- ###

### 18. 记录答题信息（更新错题本） (需要认证)
#
# !! 重要 !!
# 1. "questionId" 必须是 `questions` 表中真实存在的题目ID。
# 2. "userAnswer" 是用户提交的错误答案。
#
POST {{api_v1}}/quizzes/submit
Authorization: Bearer {{token}}
Content-Type: application/json

{
  "wrongAnswers": [
    { "questionId": 1, "userAnswer": {"answer": "A"} },
    { "questionId": 3, "userAnswer": {"answer": "D"} }
  ]
}


### 分隔符 ###
### ---------------------------------------------------- ###

### 19. 获取我的错题本列表 (需要认证)
#
# 这个接口支持分页
#
GET {{api_v1}}/notebook/wrong-questions?page=1&limit=10
Authorization: Bearer {{token}}

### 分隔符 ###
### ---------------------------------------------------- ###

### 20. 从错题本中移除一道题 (需要认证)
#
# 1. 先执行“获取我的错题本列表”请求，从返回结果中找到一个你想删除的错题的 questionId。
# 2. 将下面 URL 中的 "your_question_id" 替换为那个 id。
#
DELETE {{api_v1}}/notebook/wrong-questions/1
Authorization: Bearer {{token}}

### 分隔符 ###
### ---------------------------------------------------- ###

### 21. 提交题目纠错建议 (需要认证)
#
# "questionId" 必须是 `questions` 表中真实存在的题目ID。
#
POST {{api_v1}}/corrections
Authorization: Bearer {{token}}
Content-Type: application/json

{
  "questionId": 1,
  "suggestion": "我认为这道题的正确答案应该是 D，因为根据官方文档的描述..."
}

### 分隔符 ###
### ---------------------------------------------------- ###

### 22. AI 聊天 (需要认证)
#
# 1. "provider" 和 "model" 需要与你保存的 API Key 相匹配。
# 2. "messages" 数组模拟了前端维护的对话历史。
#
POST {{api_v1}}/chat/completions
Authorization: Bearer {{token}}
Content-Type: application/json

{
  "provider": "siliconflow",
  "model": "THUDM/GLM-4.1V-9B-Thinking",
  "messages": [
    { "role": "system", "content": "你是一个充满活力和激情的编程导师。" },
    { "role": "user", "content": "你好！请解释什么是数据库？" }
  ]
}

### 分隔符 ###
### ---------------------------------------------------- ###

### 23. 测试管理员后台访问 (需要管理员权限)
#
# 1. 执行此请求前，必须先手动将你的用户在数据库中的 role 修改为 'admin'。
# 2. 如果你是普通用户，应该会收到 403 Forbidden 错误。
# 3. 如果你是管理员，应该会收到欢迎信息。
#
GET {{api_v1}}/admin/dashboard
Authorization: Bearer {{token}}

### 分隔符 ###
### ---------------------------------------------------- ###

### 24. (管理员) 获取待审核的纠错列表
#
# 1. 确保你的用户角色是 'admin'。
# 2. 确保数据库中至少有一条用户提交的纠错建议。
# 3. 你可以修改 status 参数来查看不同状态的列表, e.g., ?status=approved
#
GET {{api_v1}}/admin/corrections?status=pending
Authorization: Bearer {{token}}

### 分隔符 ###
### ---------------------------------------------------- ###

### 25. (管理员) 批准并修正题目
#
# 1. 确保你的用户角色是 'admin'。
# 2. 先调用“获取待审核列表”接口，找到一个你想处理的 correction 的 id。
# 3. 将下面 URL 中的 "your_correction_id" 替换为那个 id。
#
PUT {{api_v1}}/admin/corrections/your_correction_id
Authorization: Bearer {{token}}
Content-Type: application/json

{
  "status": "approved",
  "updatedQuestion": {
    "content": {
      "question": "【管理员已修正】这道题的题干现在更清晰了",
      "options": ["修正后的选项A", "修正后的选项B", "修正后的选项C", "修正后的选项D"]
    },
    "answer": {
      "correctOption": "D",
      "explanation": "【管理员已修正】这是一个更准确、更详细的解析。"
    }
  }
}

### 分隔符 ###
### ---------------------------------------------------- ###

### 26. (管理员) 拒绝一个纠错建议
#
# 将下面 URL 中的 "another_correction_id" 替换为另一个建议的 id。
#
PUT {{api_v1}}/admin/corrections/another_correction_id
Authorization: Bearer {{login.response.body.data.token}}
Content-Type: application/json

{
  "status": "rejected"
}


### 分隔符 ###
### ---------------------------------------------------- ###

### 27. 搜索“我的”题库列表 (需要认证)
#
# 在 URL 中用 search 参数指定搜索关键词，例如 "MySQL"
#
GET {{api_v1}}/question-sets/my?search=MySQL
Authorization: Bearer {{token}}


### 分隔符 ###
### ---------------------------------------------------- ###

### 28. 搜索“公开”题库列表 (无需认证)
#
# 在 URL 中用 search 参数指定搜索关键词
#
GET {{api_v1}}/question-sets/public?search=高级


###
# ===============================================================
# 28. 测试标准 JSON 格式导入
# ===============================================================
POST http://localhost:3000/v1/question-sets/import
Content-Type: application/json
Authorization: Bearer {{token}}

{
  "questionSetData": {
    "title": "【JSON导入】前端基础面试题",
    "provider": "DeepSeek",
    "model": "DeepSeek-r1",
    "isPublic": false,
    "domain_major": "互联网",
    "domain_minor": "前端开发",
    "domain_detail": "JavaScript 基础",
    "difficulty": "简单",
    "questionType": "multiple_choice"
  },
  "importType": "json",
  "questions": [
    {
      "type": "multiple_choice",
      "content": {
        "question": "在 JavaScript 中，哪个关键字用于声明一个常量？",
        "options": [
          "var",
          "let",
          "const",
          "static"
        ]
      },
      "answer": {
        "correctOption": "C",
        "explanation": "'const' 用于声明一个块作用域的常量，一旦赋值后不可更改。"
      }
    },
    {
      "type": "multiple_choice",
      "content": {
        "question": " `typeof null` 的返回值是什么？",
        "options": [
          "null",
          "undefined",
          "object",
          "string"
        ]
      },
      "answer": {
        "correctOption": "C",
        "explanation": "这是一个 JavaScript 历史遗留的 bug。在 JavaScript 最初的实现中，JavaScript 中的值是由一个表示类型的标签和实际数据值表示的。对象的类型标签是 0。由于 null 代表的是空指针（大多数平台下值为 0x00），因此 null 的类型标签是 0，typeof null 也因此返回 'object'。"
      }
    }
  ]
}


###
# ===============================================================
# 29. 测试自定义文本格式导入
# ===============================================================
POST http://localhost:3000/v1/question-sets/import
Content-Type: application/json
Authorization: Bearer {{token}}

{
  "questionSetData": {
    "title": "数据库SQL挑战",
    "provider": "ChatGPT",
    "model": "GPT-4o",
    "isPublic": true,
    "domain_major": "互联网",
    "domain_minor": "后端开发",
    "domain_detail": "SQL",
    "difficulty": "中等",
    "questionType": "multiple_choice"
  },
  "importType": "text",
  "questions": "[1].哪种SQL语句用于从数据库中删除数据？\n[A].DELETE\n[B].REMOVE\n[C].COLLAPSE\n[D].ERASE\n[answer]:A\n[analysis]:DELETE 语句用于删除表中的行。\n\n[2].要对结果集进行排序，应该使用哪个SQL关键字？\n[A].SORT BY\n[B].ORDER BY\n[C].GROUP BY\n[D].ALIGN BY\n[answer]:B\n[analysis]:ORDER BY 关键字用于对结果集中的记录进行升序或降序排序。"
}

###
# ===============================================================
# 30. 测试格式错误的请求
# ===============================================================
POST http://localhost:3000/v1/question-sets/import
Content-Type: application/json
Authorization:Bearer {{token}}

{
  "questionSetData": {
    "title": "【错误格式】这是一个测试",
    "provider": "ChatGPT",
    "model": "GPT-4o",
    "isPublic": false,
    "domain_major": "其他",
    "domain_minor": "测试",
    "domain_detail": "错误处理",
    "difficulty": "简单",
    "questionType": "multiple_choice"
  },
  "importType": "text",
  "questions": "[1].这是一个格式正确的题目\n[A].选项A\n[B].选项B\n[answer]:A\n[analysis]:解析A\n\n[2].这道题缺少答案\n[A].选项A\n[B].选项B\n[analysis]:这会导致后端报错"
}
